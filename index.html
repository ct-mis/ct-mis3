<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>數學貪吃蛇</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            overflow: hidden; /* 防止捲動 */
            touch-action: none; /* 防止手機上下滑動觸發瀏覽器行為 */
        }

        #game-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            flex-direction: column;
        }

        canvas {
            background-color: #0f3460;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            max-width: 95vw;
            max-height: 80vh;
        }

        .ui-panel {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: rgba(15, 52, 96, 0.8);
            border-radius: 10px;
            margin-bottom: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            font-size: 1.1rem;
            font-weight: bold;
        }

        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .stat-label { font-size: 0.8rem; color: #a0a0a0; }
        .stat-value { font-size: 1.2rem; color: #fff; }
        .highlight { color: #e94560; }
        .success { color: #4cd137; }

        #modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        .hidden { display: none !important; }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 20px;
        }
        button:active { transform: scale(0.95); }

    </style>
</head>
<body>

<div id="game-container">
    <!-- UI 面板 -->
    <div class="ui-panel">
        <div class="stat-box">
            <span class="stat-label">目標和 (Target)</span>
            <span id="target-display" class="stat-value highlight">--</span>
        </div>
        <div class="stat-box">
            <span class="stat-label">目前和 (Current)</span>
            <span id="current-sum-display" class="stat-value">0</span>
        </div>
        <div class="stat-box">
            <span class="stat-label">分數 (Score)</span>
            <span id="score-display" class="stat-value">0</span>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- 遊戲結束/開始 模態框 -->
    <div id="modal">
        <h1 id="modal-title" class="text-4xl font-bold mb-4 text-center">數學貪吃蛇</h1>
        <p id="modal-desc" class="text-gray-300 text-center mb-6 px-4 max-w-md">
            使用方向鍵或滑動控制。<br>
            吃掉數字，使總和<b>剛好等於</b>目標數字。<br>
            若總和超過目標，蛇會爆炸！
        </p>
        <button onclick="startGame()">開始遊戲</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // 遊戲常數
    const GRID_COUNT = 24; // 24x24 格點
    const GAME_SPEED = 250; // ms (每秒4格)
    
    // 遊戲狀態
    let tileSize = 20;
    let snake = [];
    let direction = { x: 0, y: 0 };
    let nextDirection = { x: 0, y: 0 };
    let numbersOnBoard = []; // 存儲 {x, y, value}
    let targetSum = 0;
    let currentSum = 0;
    let score = 0;
    let gameLoopInterval;
    let isGameRunning = false;
    
    // 初始化 Canvas 大小
    function resizeCanvas() {
        const maxWidth = window.innerWidth * 0.95;
        const maxHeight = window.innerHeight * 0.8; // 留空間給 UI
        
        // 計算最佳 tileSize 以填滿畫面但保持 24x24
        const sizeBasedOnWidth = Math.floor(maxWidth / GRID_COUNT);
        const sizeBasedOnHeight = Math.floor(maxHeight / GRID_COUNT);
        
        tileSize = Math.min(sizeBasedOnWidth, sizeBasedOnHeight);
        
        canvas.width = tileSize * GRID_COUNT;
        canvas.height = tileSize * GRID_COUNT;
        
        if (!isGameRunning && score === 0) {
            drawGridOnly(); // 尚未開始時只畫網格
        } else if (!isGameRunning) {
            draw(); // 暫停或結束時重繪當前狀態
        }
    }
    
    window.addEventListener('resize', resizeCanvas);

    // --- 遊戲邏輯 ---

    function startGame() {
        document.getElementById('modal').classList.add('hidden');
        resetGame();
        isGameRunning = true;
        resizeCanvas();
        
        if (gameLoopInterval) clearInterval(gameLoopInterval);
        gameLoopInterval = setInterval(update, GAME_SPEED);
    }

    function resetGame() {
        // 初始蛇的位置 (中間)
        const mid = Math.floor(GRID_COUNT / 2);
        snake = [
            { x: mid, y: mid },
            { x: mid, y: mid + 1 },
            { x: mid, y: mid + 2 }
        ];
        direction = { x: 0, y: -1 }; // 初始向上
        nextDirection = { x: 0, y: -1 };
        
        score = 0;
        currentSum = 0;
        numbersOnBoard = [];
        
        spawnNumbersLevel(); // 生成 1-9
        generateTarget();
        updateUI();
    }

    function gameOver(reason) {
        isGameRunning = false;
        clearInterval(gameLoopInterval);
        
        const modal = document.getElementById('modal');
        const title = document.getElementById('modal-title');
        const desc = document.getElementById('modal-desc');
        const btn = modal.querySelector('button');
        
        modal.classList.remove('hidden');
        title.innerText = "遊戲結束";
        title.className = "text-4xl font-bold mb-4 text-center text-red-500";
        
        let reasonText = "";
        if (reason === 'wall') reasonText = "你撞牆了！";
        else if (reason === 'self') reasonText = "你咬到自己了！";
        else if (reason === 'bust') reasonText = `總和爆了！(目前 ${currentSum} > 目標 ${targetSum})`;
        
        desc.innerHTML = `${reasonText}<br>最終分數: ${score}<br>再試一次？`;
        btn.innerText = "重新開始";
    }

    function spawnNumbersLevel() {
        // 生成 1 到 9 的數字
        // 如果場上已經有數字，保留它們嗎？題目說 "被吃掉的數字不會再出現"，暗示這是一波一波的
        // 為了遊戲延續性，當無法組成目標時，我們重新填滿 1-9 中缺失的數字，或者清空並重新生成
        // 這裡採用簡單邏輯：清空場上剩餘，重新生成完整 1-9
        
        numbersOnBoard = [];
        const possiblePositions = [];
        
        // 找出所有空位
        for (let x = 0; x < GRID_COUNT; x++) {
            for (let y = 0; y < GRID_COUNT; y++) {
                if (!isSnake(x, y)) {
                    possiblePositions.push({x, y});
                }
            }
        }
        
        // 隨機放置 1-9
        for (let i = 1; i <= 9; i++) {
            if (possiblePositions.length === 0) break;
            
            const randIndex = Math.floor(Math.random() * possiblePositions.length);
            const pos = possiblePositions[randIndex];
            
            numbersOnBoard.push({
                x: pos.x,
                y: pos.y,
                value: i
            });
            
            // 移除已使用的位置
            possiblePositions.splice(randIndex, 1);
        }
    }

    // 檢查目標是否可行（子集和問題，因為數字少，用遞歸窮舉即可）
    function canSumTo(numbers, target) {
        // 尋找數組中是否有子集和為 target
        function check(index, current) {
            if (current === target) return true;
            if (current > target || index >= numbers.length) return false;
            
            // 選這個數 或 不選這個數
            return check(index + 1, current + numbers[index]) || check(index + 1, current);
        }
        return check(0, 0);
    }

    // 隨機生成一個目標和，必須是兩位數 (>=10)，且必須能由場上數字組成
    function generateTarget() {
        const values = numbersOnBoard.map(n => n.value);
        
        // 找出所有可能的組合和
        let possibleSums = new Set();
        
        // 使用二進制枚舉所有子集 (數字最多9個，2^9=512，很快)
        const totalSubsets = 1 << values.length;
        for (let i = 1; i < totalSubsets; i++) {
            let sum = currentSum; // 加上當前已有的總和
            for (let j = 0; j < values.length; j++) {
                if ((i >> j) & 1) {
                    sum += values[j];
                }
            }
            if (sum >= 10 && sum <= 99) { // 限制兩位數
                possibleSums.add(sum);
            }
        }
        
        const validTargets = Array.from(possibleSums);
        
        if (validTargets.length === 0) {
            // 場上數字太少或太小，無法組成兩位數
            // 進入下一波 (保留蛇的狀態，重置數字)
            spawnNumbersLevel();
            // 重新遞歸嘗試生成
            // 為了避免死循環 (萬一 currentSum 已經很大導致無法生成兩位數?)
            // 如果 currentSum 已經 >= 10，那現在就是目標達成狀態 (不應該發生，因為達成會立即結算)
            // 如果 currentSum < 10，新生成的1-9一定能湊出 >= 10
            
            // 重新計算可用目標
            const newValues = numbersOnBoard.map(n => n.value);
            // 這裡簡單遞歸一次
            // 注意：如果遞歸這裡要小心堆疊，但邏輯上只會發生一次重置
            
            // 簡單處理：如果重置後還是沒有 (極罕見)，直接給一個預設值讓玩家必須吃特定數字
            // 但有了1-9，最小是1+2+currentSum，最大是45+currentSum，肯定有兩位數
            
            // 再次執行生成邏輯 (不遞歸，直接跑下面邏輯)
            let newSums = [];
            const allSubsets = 1 << newValues.length;
            for(let i=1; i<allSubsets; i++) {
                let s = currentSum;
                for(let j=0; j<newValues.length; j++) {
                    if((i>>j)&1) s += newValues[j];
                }
                if(s>=10 && s<=99) newSums.push(s);
            }
            targetSum = newSums[Math.floor(Math.random() * newSums.length)];
        } else {
            targetSum = validTargets[Math.floor(Math.random() * validTargets.length)];
        }
        
        updateUI();
    }

    function update() {
        // 更新方向
        direction = nextDirection;
        
        const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
        
        // 1. 檢查撞牆
        if (head.x < 0 || head.x >= GRID_COUNT || head.y < 0 || head.y >= GRID_COUNT) {
            gameOver('wall');
            return;
        }
        
        // 2. 檢查撞自己
        if (isSnake(head.x, head.y)) {
            gameOver('self');
            return;
        }
        
        snake.unshift(head); // 移動頭部
        
        // 3. 檢查吃數字
        let eatenIndex = -1;
        for (let i = 0; i < numbersOnBoard.length; i++) {
            if (numbersOnBoard[i].x === head.x && numbersOnBoard[i].y === head.y) {
                eatenIndex = i;
                break;
            }
        }
        
        if (eatenIndex !== -1) {
            // 吃到數字
            const val = numbersOnBoard[eatenIndex].value;
            currentSum += val;
            numbersOnBoard.splice(eatenIndex, 1); // 移除該數字
            
            // 判斷邏輯
            if (currentSum === targetSum) {
                // 達成目標
                score += targetSum;
                currentSum = 0;
                // 成功才保留尾巴長度 (相當於變長了，因為這次沒 pop)
                // 並且產生新目標
                generateTarget();
                flashEffect('#4cd137');
            } else if (currentSum > targetSum) {
                // 爆掉了
                gameOver('bust');
                return;
            } else {
                // 尚未達成，但吃到數字，蛇身長度增加 (沒 pop)
                // 繼續遊戲，等待下一個數字
            }
        } else {
            // 沒吃到東西，移除尾巴 (維持長度)
            snake.pop();
        }
        
        updateUI();
        draw();
    }

    // 輔助：判斷座標是否是蛇身 (不含頭，用於判斷撞擊，或含頭用於生成檢查)
    function isSnake(x, y, ignoreHead = false) {
        const start = ignoreHead ? 1 : 0;
        for (let i = start; i < snake.length; i++) {
            if (snake[i].x === x && snake[i].y === y) return true;
        }
        return false;
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('target-display').innerText = targetSum;
        document.getElementById('current-sum-display').innerText = currentSum;
        
        const curEl = document.getElementById('current-sum-display');
        if (currentSum > 0) curEl.classList.add('text-yellow-400');
        else curEl.classList.remove('text-yellow-400');
    }

    function flashEffect(color) {
        canvas.style.borderColor = color;
        canvas.style.boxShadow = `0 0 30px ${color}`;
        setTimeout(() => {
            canvas.style.borderColor = 'transparent';
            canvas.style.boxShadow = '0 0 20px rgba(0, 0, 0, 0.5)';
        }, 300);
    }

    // --- 繪圖 ---

    function drawGridOnly() {
        ctx.fillStyle = '#0f3460';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.strokeStyle = '#16213e';
        ctx.lineWidth = 1;
        for (let i = 0; i <= GRID_COUNT; i++) {
            ctx.beginPath();
            ctx.moveTo(i * tileSize, 0);
            ctx.lineTo(i * tileSize, canvas.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, i * tileSize);
            ctx.lineTo(canvas.width, i * tileSize);
            ctx.stroke();
        }
    }

    function draw() {
        // 清空背景
        drawGridOnly();

        // 畫數字
        ctx.font = `bold ${tileSize * 0.8}px 'Noto Sans TC'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        numbersOnBoard.forEach(num => {
            const px = num.x * tileSize + tileSize / 2;
            const py = num.y * tileSize + tileSize / 2;
            
            // 數字背景圈
            ctx.fillStyle = '#1f4068';
            ctx.beginPath();
            ctx.arc(px, py, tileSize * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // 數字
            ctx.fillStyle = '#fff';
            ctx.fillText(num.value, px, py + 1); // +1 微調垂直置中
        });

        // 畫蛇
        snake.forEach((part, index) => {
            const px = part.x * tileSize;
            const py = part.y * tileSize;
            
            // 蛇身顏色漸變
            if (index === 0) {
                ctx.fillStyle = '#4cd137'; // 頭
            } else {
                // 越後面越暗
                const opacity = 1 - (index / (snake.length + 5));
                ctx.fillStyle = `rgba(76, 209, 55, ${Math.max(0.3, opacity)})`;
            }
            
            // 稍微縮小一點讓格子分明
            ctx.fillRect(px + 1, py + 1, tileSize - 2, tileSize - 2);
            
            // 畫眼睛 (如果是頭)
            if (index === 0) {
                ctx.fillStyle = '#000';
                // 根據方向畫眼睛位置
                const eyeSize = tileSize * 0.15;
                const offset = tileSize * 0.25;
                // 簡單處理，固定畫兩個點
                ctx.fillRect(px + offset, py + offset, eyeSize, eyeSize);
                ctx.fillRect(px + tileSize - offset - eyeSize, py + offset, eyeSize, eyeSize);
            }
        });
    }

    // --- 輸入控制 ---
    
    // 鍵盤
    window.addEventListener('keydown', e => {
        if (!isGameRunning) return;
        
        switch(e.key) {
            case 'ArrowUp':
                if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                break;
            case 'ArrowDown':
                if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                break;
            case 'ArrowLeft':
                if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                break;
            case 'ArrowRight':
                if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                break;
        }
    });

    // 觸控 (滑動)
    let touchStartX = 0;
    let touchStartY = 0;
    
    canvas.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        e.preventDefault(); // 防止滾動
    }, {passive: false});
    
    canvas.addEventListener('touchmove', e => {
         e.preventDefault(); // 防止滾動
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        if (!isGameRunning) return;
        
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        
        if (Math.abs(dx) > Math.abs(dy)) {
            // 水平滑動
            if (dx > 0 && direction.x === 0) nextDirection = { x: 1, y: 0 };
            else if (dx < 0 && direction.x === 0) nextDirection = { x: -1, y: 0 };
        } else {
            // 垂直滑動
            if (dy > 0 && direction.y === 0) nextDirection = { x: 0, y: 1 };
            else if (dy < 0 && direction.y === 0) nextDirection = { x: 0, y: -1 };
        }
    });

    // 初始化一次大小
    resizeCanvas();

</script>
</body>
</html>